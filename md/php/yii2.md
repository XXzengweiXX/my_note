# 介绍

yii是一个高性能的，适用于开发web应用的php框架。

yii再带了丰富的功能，包括mvc，dao/activerecord，l18n/l10n缓存，身份验证和基于角色的访问控制，脚手架，测试等，可以显著缩短开发时间。

yii可以通过gii脚手架快速生成代码，快速生成控制与模型，这点与laravel的artisan有类似的功能，但是yii没有刻板地遵照某种设计模式而对代码进行过度设计，有利于增加代码的可读性。

# 文件目录

![image-20200212101418068](C:\Users\13350\AppData\Roaming\Typora\typora-user-images\image-20200212101418068.png)

# Gii脚手架

可以通过gii脚手架快速生成模型，控制器，模块等

![image-20200212102214075](C:\Users\13350\AppData\Roaming\Typora\typora-user-images\image-20200212102214075.png)

通过gii生成的模块需要到应用主体中添加配置，否者无法使用。例如在项目根目录下生成了一个forum模块，需要到config/web.php配置文件中添加该模块信息，信息如下：

![image-20200212102858533](C:\Users\13350\AppData\Roaming\Typora\typora-user-images\image-20200212102858533.png)

forum为模块标识，是d唯一的，class指向的模块的类文件

# 控制器

可对外访问的控制器中的方法都是以action为前缀的，如访问forum/indexController中的详情，方法名为actionShow，访问地址为http://127.0.0.1:8080/index.php?r=forum/index/show, 如果将方法名改为show，则无法访问到该方法。

如果控制器或者方法名含有多个单词，需要把大写字母转化为小写，并用-连接，如访问forum/indexController中的actionMyPost,访问地址为http://127.0.0.1:8080/index.php?r=forum/index/my-post

参数接受

```php
public function actionShow($id){
//todo
}
```

此时可以通过?r=forum/index/show&id=2来对id赋值，此时$id=2

# 模型

模型一般放在models中。

模型中可以添加·`attributeLabels`方法对字段属性进行转化，

```php
public functiion attributeLables(){
	return [
		'code',//不修改
        'name'=>function(){
                return 'country'.'_'.$this->name;
            },//将那么变成country_$this->name
        'population'=>'popu'
	];
}
```

设置`rules`方法对字段进行验证，yii[自带的验证规则](https://www.yiichina.com/tutorial/635)

``` php
public function rules(){
    ['name','required'],//第一个元素为需要验证的字段，第二个元素为验证规则
    ['email','email'],
}
```

验证规则一般配合场景`scenarios`使用，如登陆时需要验证哪些字段，注册时需要验证哪些字段

``` php
public function scenarios(){
    return [
      'login'=>['name','pwd','email'],
        'register'=>['name','pwd']
    ];
}
```

验证字段时先实例化model，再设置场景，通过validate来验证字段的合法性：

``` php
$model = new model;
$model->scenario = 'login';
if($model->validate()){
    //验证通过
}elss{
    //不通过原因，数组形式
    $errors = $model->errors;
}
```

# 视图

yii中有默认布局，默认布局的配置在assets/AppAssets.php中，默认布局文件为views/layouts/main.php.可以在控制器中修改layout来修改默认布局：

``` php
class PostController extends Controller{
    //将默认布局有main改为post
    public $layout = 'post';
}
```

在控制器中调用$this->render(viewName)来渲染视图，此方法会默认使用布局，如果不想使用布局，可以使用$this->renderPartial(viewName),viewName为视图文件。

在视图中可以使用yii自带的函数快速构建视图：

``` php
<?php
use yii\widgets\ActiveForm;
use yii\helpers\Html;
?>
<!--生成表单-->
<?php $activeForm = ActiveForm::begin() ?>
<?= $activeForm->field($form,'name')->label('姓名') ?>
<?= $activeForm->field($form,'phone')->label('手机') ?>
<div class="form-group">
    <?= Html::submitButton('提交',['class'=>'btn btn-primary']) ?>
</div>
<?php $activeForm::end() ?>
```

效果图如下：

![image-20200212113544269](C:\Users\13350\AppData\Roaming\Typora\typora-user-images\image-20200212113544269.png)

# 小部件

小部件是在视图中使用的可重用单元，使用面向对象方式创建复杂和可配置用户界面单元。 例如，日期选择器小部件可生成一个精致的允许用户选择日期的日期选择器， 你只需要在视图中插入如下代码：

``` php
<?php 
    use yii\jui\DatePicker;
?>
    <?= DatePicker::widget(['name'=>'date'])?>
```

一些小部件可在 yii\base\Widget::begin() 和 yii\base\Widget::end()调用中使用数据内容。 例如生成表单， 小部件会在 `begin()` 和 `end()` 执行处分别生成 form 的开始标签和结束标签， 中间的任何代码也会被渲染。

``` php
<?php
use yii\widgets\ActiveForm;
use yii\helpers\Html;
?>
<?php $form = ActiveForm::begin(['id' => 'login-form']); ?>
    <?= $form->field($model, 'username') ?>
    <?= $form->field($model, 'password')->passwordInput() ?>
    <div class="form-group">
        <?= Html::submitButton('Login') ?>
    </div>
<?php ActiveForm::end(); ?>
```

## 创建小部件

> 使用widget()方法

继承 yii\base\Widget类并覆盖 yii\base\Widget::init() 和/或 yii\base\Widget::run()方法可创建小部件。通常 `init()` 方法处理小部件属性， `run()` 方法包含小部件生成渲染结果的代码。 渲染结果可以直接“输出”或通过 `run()` 方法作为字符串返回。

``` php
<?php
namespace app\widgets;
use yii\base\Widget;
use yii\helpers\Html;

class MyMsg extends Widget
{
    public $msg;
    public function init()
    {
        parent::init();
        if ($this->msg==null){
            $this->msg = 'hello world';
        }
    }
    public function run()
    {
        return Html::encode($this->msg);
    }
}
```

调用此小部件：

```php
<?=\app\widgets\MyMsg::widget(['msg'=>'go go']) ?>
```

> 使用begin()与end()方法

PHP 输出缓冲在 `init()` 启动，所有在 `init()` 和 `run()` 方法之间的输出内容都会被获取，并在 `run()` 处理和返回。

``` php
<?php
namespace app\widgets;

use yii\base\Widget;

class MyContent extends Widget
{
    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        ob_start();
    }

    public function run()
    {
        $content = ob_get_clean();
        return $this->render('mycontent',compact('content'));
    }
}
```

调用此小部件：

``` php
<?php \app\widgets\MyContent::begin();?>
this content<br>
just content
<?php \app\widgets\MyContent::end(); ?>
```

# 请求

``` php
$request = Yii::$app->request;
//获取get参数
$getParams = $request->get();
//获取post参数
$postParams = $request->post();
//单独获取某个参数，如果没有，设置默认值
$id = $request->get('id',1);
//获取头部信息
$header = $request->headers;
```

# 错误处理

Yii 内置了一个error handler错误处理器，它使错误处理更方便， Yii错误处理器做以下工作来提升错误处理效果：

- 所有非致命PHP错误（如，警告，提示）会转换成可获取异常；
- 异常和致命的PHP错误会被显示， 在调试模式会显示详细的函数调用栈和源代码行数。
- 支持使用专用的控制器操作来显示错误；
- 支持不同的错误响应格式；

错误处理可以在config/web.php中进行配置

``` php
'components' => [
    'errorHandler' => [
        //异常页面最多显示20行源码
        'maxSourceLines' => 20,
        //指定错误处理的方法，在此方法里面可以对错误进行处理记录，也可以返回自定义错误格式
        'errorAction' => 'site/error',
    ],
],
```

 # 事件

事件可以将自定义代码“注入”到现有代码中的特定执行点。 附加自定义代码到某个事件，当这个事件被触发时，这些代码就会自动执行。

事件处理器是一个PHP 回调函数， 当它所附加到的事件被触发时它就会执行。可以使用以下回调函数之一：

- 字符串形式指定的 PHP 全局函数，如 `'trim'` ；
- 对象名和方法名数组形式指定的对象方法，如 `[$object, $method]` ；
- 类名和方法名数组形式指定的静态类方法，如 `[$class, $method]` ；
- 匿名函数，如 `function ($event) { ... }` 。

事件一般是通过on()来设置监听事件，trigger()来触发事件,off()取消事件。

cat :

```php
<?php
namespace app\events;

use yii\base\Component;

class CatEvent extends Component
{
    const CAT_SHOUT='cat_shout';

    public function shout(){
        echo "miao<br/>";
        //触发事件
        $this->trigger(static::CAT_SHOUT);
    }

}
```

mouse:

```php
<?php


namespace app\events;


use yii\base\Component;

class MouseEvent extends Component
{

    public function run(){
        echo "just run!<br/>";
    }

}
```

dog:

```php
<?php


namespace app\events;


use yii\base\Component;
use yii\base\Event;

class DogEvent extends Component
{

    public function where(Event $event){
        //获取数据
        $name = $event->data;
        echo "where is my {$name}<br/>";
    }

}
```

调用cat并触发事件：

```php
 $cat = new CatEvent();
$mouse = new MouseEvent();
//监听事件
$cat->on(CatEvent::CAT_SHOUT,[$mouse,'run']);
$cat->on(CatEvent::CAT_SHOUT,[DogEvent::class,'where'],'my little cat');
//调用shout并触发事件
$cat->shout();
```

# 别名

别名用来表示文件路径和 URL，这样就避免了在代码中硬编码一些绝对路径和 URL。 一个别名必须以 `@` 字符开头，以区别于传统的文件路径和 URL。 没有前导 `@` 定义的别名将以 `@` 字符作为前缀。

可以调用 Yii::setAlias() 来给文件路径或 URL 定义别名：

```php
// 文件路径的别名
Yii::setAlias('@foo', '/path/to/foo');

// URL 的别名
Yii::setAlias('@bar', 'http://www.example.com');

// 包含 \foo\Bar 类的具体文件的别名
Yii::setAlias('@foo/Bar.php', '/definitely/not/foo/Bar.php');
```

可以调用 Yii::getAlias() 命令来解析根别名到对应的文件路径或 URL:

```php
echo Yii::getAlias('@foo');               // 输出：/path/to/foo
echo Yii::getAlias('@bar');               // 输出：http://www.example.com
echo Yii::getAlias('@foo/bar/file.php');  // 输出：/path/to/foo/bar/file.php
```

# 缓存

> 配置

在config/web.php中进行配置

``` php
'components'=>[
    'cache'=>[
        'class'=>'yii\caching\FileCache',//文件缓存
        //'class'=>'yii\caching\MemCache',//memcach缓存
        //'class'=>'yii\caching\DbCache',//数据库缓存
        //'class'=>'yii\redis\Cache',//redis缓存
        
    ]
]
```

> 片段缓存

片段缓存指的是缓存页面内容中的某个片段。例如，一个页面显示了逐年销售额的摘要表格， 可以把表格缓存下来，以消除每次请求都要重新生成表格的耗时。 片段缓存是基于数据缓存实现的。

视图中使用方法如下,调用beginCache()与endCache()生成缓存逻辑，并且需要个每一个缓存片段一个唯一的id，可以设置duration来设置缓存事件，单位为秒，不设置默认60秒。还可以通过renderDynamic()方法传递动态数据

```  php
if ($this->beginCache($id,['duration'=>120])){
    //=====
    cache data
    /=====
    //动态数据
    echo $this->renderDynamic($newData)    
    $this->endCache();
}
```

> 页面缓存

页面缓存指的是在服务器端缓存整个页面的内容。 随后当同一个页面被请求时，内容将从缓存中取出，而不是重新生成。页面缓存需要在控制器里面的behaviors里面进行设置。

```php
public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\PageCache',//缓存支持类
            'only' => ['index'],//需要控制器的方法
            'duration' => 60,//缓存事件
            'variations' => [
                \Yii::$app->language,
            ],
            'dependency' => [//缓存依赖，即在这里是数据库中post数量变化之后更新缓存
                'class' => 'yii\caching\DbDependency',
                'sql' => 'SELECT COUNT(*) FROM post',
            ],
        ],
    ];
}
```

> http缓存

http缓存可以利用客户端缓存 去节省相同页面内容的生成和传输时间。该缓存仅对 `GET` 和 `HEAD` 请求生效， 它能为这些与缓存有关的 HTTP 头。

通过配置 yii\filters\HttpCache::$lastModified 属性向客户端发送 `Last-Modified` 头。 该属性的值应该为 PHP callable 类型，返回的是页面修改时的 Unix 时间戳。

```php
public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\HttpCache',
            'only' => ['index'],
            'lastModified' => function ($action, $params) {
                $q = new \yii\db\Query();
                return $q->from('post')->max('updated_at');
            },
        ],
    ];
}
```

